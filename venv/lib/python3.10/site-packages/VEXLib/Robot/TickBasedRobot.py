from vex import *
from VEXLib import Units
from VEXLib.Util import time, pass_function
from .Constants import *


class TickBasedRobot:
    def __init__(self, brain: Brain):
        # Create a new competition object
        # and initialize the callbacks for driver and autonomous control to a "pass function".
        # This means that the robot will not automatically run code when it is enabled or disabled
        # We do this because we would like to handle running the state machine and callbacks ourselves.
        # This allows for more predictable behaviors and the injection of additional functionality
        self._competition = Competition(
            pass_function, pass_function
        )

        self.brain = brain

        self._target_tick_duration_ms = TARGET_TICK_DURATION_MS
        self._warning_tick_duration_ms = WARNING_TICK_DURATION_MS

        self._enabled = True
        self.restart_requested = False
        self._previous_enabled = self._enabled
        self._update_enabled()

        self._last_enable_time = self._last_disable_time = None

        if self._enabled:
            self._last_enable_time = time.time()
        else:
            self._last_disable_time = time.time()

        self._mode = DRIVER_CONTROL_MODE
        self._previous_mode = self._mode
        self._update_mode()

        self._current_time = None
        self._update_time()
        self._last_tick_time = self._current_time

    def start(self):
        # Run the user-defined setup method
        self.setup()
        # Start the mainloop, this handles calling periodic and instant callbacks
        self._mainloop()

    def trigger_restart(self):
        self.restart_requested = True

    def _update_time(self):
        self._current_time = time.time()

    def _update_enabled(self):
        if self._competition.is_field_control():
            self._enabled = self._competition.is_enabled()
        elif self._competition.is_competition_switch():
            self._enabled = self._competition.is_enabled()
        else:
            # There is nothing controlling the mode, so the default is driver control enabled
            self._enabled = True
        self._previous_enabled = self._enabled

    def _update_mode(self):
        if self._competition.is_field_control():
            self._mode = AUTONOMOUS_MODE if self._competition.is_autonomous() else DRIVER_CONTROL_MODE
        elif self._competition.is_competition_switch():
            self._mode = AUTONOMOUS_MODE if self._competition.is_autonomous() else DRIVER_CONTROL_MODE
        else:
            # There is nothing controlling the mode, so the default is driver control enabled
            self._mode = DRIVER_CONTROL_MODE
        self._previous_mode = self._mode

    def _update_state(self):
        self._update_enabled()
        self._update_mode()
        self._update_time()

    def _mainloop(self):
        """
        Handle internal competition state logic
        """
        self._handle_instant_callbacks()  # Force a manual call to instant callbacks for initial setup
        while True:
            self._update_state()

            if self._mode != self._previous_mode:
                # If the mode has changed since last update
                # then run the appropriate instant callbacks
                self._handle_instant_callbacks()

            self._handle_periodic_callbacks()  # Run the appropriate periodic callbacks every update

    def get_tick_time(self):
        return self._current_time

    def setup(self):
        """
        Run when the program is started to set up the robot (autonomous selection screen, calibration, etc.)
        This method is run before all other methods (on_enable, periodic, disabled_periodic, etc.) and blocks execution until it finishes.
        """

    def _handle_instant_callbacks(self):
        if self._enabled:
            self._handle_enable_callbacks()
        else:
            self._handle_disable_callbacks()

    def _handle_enable_callbacks(self):
        """
        Handle callbacks when the robot is enabled
        """
        self._last_enable_time = time.time()
        self.on_enable()
        if self.is_autonomous_control():
            self.on_autonomous()
        elif self.is_driver_control():
            self.on_driver_control()

    def _handle_disable_callbacks(self):
        """
        Handle callbacks when the robot is disabled
        """
        self._last_disable_time = time.time()
        self.on_disable()
        if self.is_autonomous_control():
            self.on_autonomous_disable()
        elif self.is_driver_control():
            self.on_driver_control_disable()

    def _handle_periodic_callbacks(self):
        """
        Handle periodic callbacks
        """
        elapsed_time = self._current_time - self._last_tick_time
        if elapsed_time >= Units.milliseconds_to_seconds(self._warning_tick_duration_ms):
            self.brain.screen.print("WARNING: Loop overrun: Tick time of " + str(Units.seconds_to_milliseconds(elapsed_time)) + "ms exceeds " + str(
                self._warning_tick_duration_ms) + "ms")
            self.brain.screen.next_row()
            print("WARNING: Loop overrun: Tick time of " + str(Units.seconds_to_milliseconds(elapsed_time)) + "ms exceeds " + str(
                self._warning_tick_duration_ms) + "ms")
        if elapsed_time >= Units.milliseconds_to_seconds(self._target_tick_duration_ms):
            self._handle_periodic_callbacks_internal()

    def _handle_periodic_callbacks_internal(self):
        """
        Handle the internal logic for periodic callbacks
        """
        if self._enabled:
            if self.is_driver_control():
                self.driver_control_periodic()
            elif self.is_autonomous_control():
                self.autonomous_periodic()
            self.enabled_periodic()
        else:
            self.disabled_periodic()

        self.periodic()
        self._last_tick_time = self._current_time

    """Instant callbacks"""

    def on_enable(self):
        """
        Run whenever the robot is enabled while in either autonomous or driver control mode
        This means that this method is also executed when the robot is enabled and is switched from autonomous to driver control mode or vice versa
        """

    def on_disable(self):
        """
        Run whenever the robot is disabled while in either autonomous or driver control mode
        This means that this method is also executed when the robot is disabled and is switched from autonomous to driver control mode or vice versa
        """

    def on_driver_control(self):
        """
        Run whenever the robot is enabled while in driver control mode or is enabled and switches from autonomous to driver control
        """

    def on_driver_control_disable(self):
        """
        Run whenever the robot is disabled while in driver control mode or is disabled and switches from autonomous to driver control
        """

    def on_autonomous(self):
        """
        Run whenever the robot is enabled while in autonomous mode or is enabled and switches from driver control to autonomous
        """

    def on_autonomous_disable(self):
        """
        Run whenever the robot is disabled while in autonomous mode or is disabled and switches from driver control to autonomous
        """

    """Periodic callbacks"""

    def periodic(self):
        """
        Run periodically approximately 50 times a second (20ms between ticks) no matter the competition mode
        """

    def driver_control_periodic(self):
        """
        Run periodically approximately 50 times a second (20ms between ticks) while driver control is enabled
        """

    def autonomous_periodic(self):
        """
        Run periodically approximately 50 times a second (20ms between ticks) while autonomous is enabled
        """

    def enabled_periodic(self):
        """
        Run periodically approximately 50 times a second (20ms between ticks) while the robot is enabled in either autonomous or driver control mode
        """

    def disabled_periodic(self):
        """
        Run periodically approximately 50 times a second (20ms between ticks) while the robot is disabled in either autonomous or driver control mode
        """

    """Polling methods"""

    def is_enabled(self):
        """
        Get whether the robot is currently enabled
        """
        return self._enabled

    def is_disabled(self):
        """
        Get whether the robot is currently disabled
        """
        return not self._enabled

    def is_driver_control(self):
        """
        Get whether the robot is currently in driver control mode
        """
        return self._mode == DRIVER_CONTROL_MODE

    def is_autonomous_control(self):
        """
        Get whether the robot is currently in autonomous control mode
        """
        return self._mode == AUTONOMOUS_MODE
