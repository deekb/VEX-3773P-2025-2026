from vex import *
from VEXLib import Units
from VEXLib.Util import time, pass_function
from VEXLib.Robot.Constants import *
from VEXLib.Robot.RobotBase import RobotBase


class TickBasedRobot(RobotBase):
    def __init__(self, brain: Brain):
        super().__init__(brain)

        # Create a new competition object
        # and initialize the callbacks for driver and autonomous control to a "pass function".
        # This means that the robot will not automatically run code when it is enabled or disabled
        # We do this because we would like to handle running the state machine and callbacks ourselves.
        # This allows for more predictable behaviors and the injection of additional functionality
        self._competition = Competition(
            pass_function, pass_function
        )

        self._target_tick_duration_ms = TARGET_TICK_DURATION_MS
        self._warning_tick_duration_ms = WARNING_TICK_DURATION_MS

        self._enabled = True
        self.restart_requested = False
        self._previous_enabled = self._enabled
        self._update_enabled()

        self._last_enable_time = self._last_disable_time = None

        if self._enabled:
            self._last_enable_time = time.time()
        else:
            self._last_disable_time = time.time()

        self._mode = DRIVER_CONTROL_MODE
        self._previous_mode = self._mode
        self._update_mode()

        self._current_time = None
        self._update_time()
        self._last_tick_time = self._current_time

    def start(self):
        # Run the user-defined setup method
        self.setup()
        # Start the mainloop, this handles calling periodic and instant callbacks
        self._mainloop()

    def trigger_restart(self):
        self.restart_requested = True

    def _update_time(self):
        self._current_time = time.time()

    def _update_enabled(self):
        if self._competition.is_field_control():
            self._enabled = self._competition.is_enabled()
        elif self._competition.is_competition_switch():
            self._enabled = self._competition.is_enabled()
        else:
            # There is nothing controlling the mode, so the default is driver control enabled
            self._enabled = True
        self._previous_enabled = self._enabled

    def _update_mode(self):
        if self._competition.is_field_control():
            self._mode = AUTONOMOUS_MODE if self._competition.is_autonomous() else DRIVER_CONTROL_MODE
        elif self._competition.is_competition_switch():
            self._mode = AUTONOMOUS_MODE if self._competition.is_autonomous() else DRIVER_CONTROL_MODE
        else:
            # There is nothing controlling the mode, so the default is driver control enabled
            self._mode = DRIVER_CONTROL_MODE
        self._previous_mode = self._mode

    def _update_state(self):
        self._update_enabled()
        self._update_mode()
        self._update_time()

    def _mainloop(self):
        """
        Handle internal competition state logic
        """
        self._update_state()
        self._handle_instant_callbacks()  # Force a manual call to instant callbacks for initial setup
        while True:
            self._update_state()

            if self._mode != self._previous_mode:
                # If the mode has changed since last update
                # then run the appropriate instant callbacks
                self._handle_instant_callbacks()

            self._handle_periodic_callbacks()  # Run the appropriate periodic callbacks every update

    def get_tick_time(self):
        return self._current_time

    def setup(self):
        """
        Run when the program is started to set up the robot (autonomous selection screen, calibration, etc.)
        This method is run before all other methods (on_enable, periodic, disabled_periodic, etc.) and blocks execution until it finishes.
        """

    def _handle_instant_callbacks(self):
        if self._enabled:
            self._handle_enable_callbacks()
        else:
            self._handle_disable_callbacks()

    def _handle_enable_callbacks(self):
        """
        Handle callbacks when the robot is enabled
        """
        self._last_enable_time = time.time()
        self.on_enable()
        if self.is_autonomous_control():
            self.on_autonomous()
        elif self.is_driver_control():
            self.on_driver_control()

    def _handle_disable_callbacks(self):
        """
        Handle callbacks when the robot is disabled
        """
        self._last_disable_time = time.time()
        self.on_disable()
        if self.is_autonomous_control():
            self.on_autonomous_disable()
        elif self.is_driver_control():
            self.on_driver_control_disable()

    def _handle_periodic_callbacks(self):
        """
        Handle periodic callbacks
        """
        elapsed_time = self._current_time - self._last_tick_time
        if elapsed_time >= Units.milliseconds_to_seconds(self._warning_tick_duration_ms):
            self.brain.screen.print("WARNING: Loop overrun: Tick time of " + str(Units.seconds_to_milliseconds(elapsed_time)) + "ms exceeds " + str(
                self._warning_tick_duration_ms) + "ms")
            self.brain.screen.next_row()
            print("WARNING: Loop overrun: Tick time of " + str(Units.seconds_to_milliseconds(elapsed_time)) + "ms exceeds " + str(
                self._warning_tick_duration_ms) + "ms")
        if elapsed_time >= Units.milliseconds_to_seconds(self._target_tick_duration_ms):
            self._handle_periodic_callbacks_internal()

    def _handle_periodic_callbacks_internal(self):
        """
        Handle the internal logic for periodic callbacks
        """
        if self._enabled:
            if self.is_driver_control():
                self.driver_control_periodic()
            elif self.is_autonomous_control():
                self.autonomous_periodic()
            self.enabled_periodic()
        else:
            self.disabled_periodic()

        self.periodic()
        self._last_tick_time = self._current_time

    """Polling methods"""

    def is_enabled(self):
        """
        Get whether the robot is currently enabled
        """
        return self._enabled

    def is_disabled(self):
        """
        Get whether the robot is currently disabled
        """
        return not self._enabled

    def is_driver_control(self):
        """
        Get whether the robot is currently in driver control mode
        """
        return self._mode == DRIVER_CONTROL_MODE

    def is_autonomous_control(self):
        """
        Get whether the robot is currently in autonomous control mode
        """
        return self._mode == AUTONOMOUS_MODE
