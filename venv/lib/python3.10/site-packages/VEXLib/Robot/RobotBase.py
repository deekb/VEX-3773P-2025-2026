from vex import *
from VEXLib import Units, MathUtil
from VEXLib.Util import time
from .Constants import *


class RobotBase:
    def __init__(self, brain: Brain):
        # Create a new competition object
        # and initialize the callbacks for driver and autonomous control to a universal lambda pass function.
        # This is because we would like to handle running the state machine and callbacks ourselves.
        # This allows for more predictable behaviors and the injection of additional functionality
        self._competition = Competition(
            lambda *args, **kwargs: None,
            lambda *args, **kwargs: None
        )

        self.brain = brain

        self._target_tick_duration_ms = TARGET_TICK_DURATION_MS
        self._warning_tick_duration_ms = WARNING_TICK_DURATION_MS

        self._enabled = None
        self._previous_enabled = self._enabled
        self._update_enabled()

        self._last_enable_time = self._last_disable_time = None

        if self._enabled:
            self._last_enable_time = time.time()
        else:
            self._last_disable_time = time.time()

        self._mode = None
        self._previous_mode = self._mode
        self._update_mode()

        self._current_time = None
        self._update_time()
        self._last_tick_time = self._current_time

    def start(self):
        # Run the user-defined setup method
        self.setup()
        # Start the mainloop, this handles calling periodic and instant callbacks
        self._mainloop()

    def _update_time(self):
        self._current_time = time.time()

    def _update_enabled(self):
        if self._competition.is_field_control():
            self._enabled = self._competition.is_enabled()
        elif self._competition.is_competition_switch():
            self._enabled = self._competition.is_enabled()
        else:
            # There is nothing controlling the mode, so the default is driver control enabled
            self._enabled = True
        self._previous_enabled = self._enabled

    def _update_mode(self):
        if self._competition.is_field_control():
            self._mode = AUTONOMOUS_MODE if self._competition.is_autonomous() else DRIVER_CONTROL_MODE
        elif self._competition.is_competition_switch():
            self._mode = AUTONOMOUS_MODE if self._competition.is_autonomous() else DRIVER_CONTROL_MODE
        else:
            # There is nothing controlling the mode, so the default is driver control enabled
            self._mode = DRIVER_CONTROL_MODE
        self._previous_mode = self._mode

    def _update_state(self):
        self._update_enabled()
        self._update_mode()
        self._update_time()

    def setup(self):
        """
        Run when the program is started to set up the robot (autonomous selection screen, calibration, etc.)
        This method is run before all other methods (on_enable, periodic, disabled_periodic, etc.) and blocks execution until it finishes.
        """

    def _mainloop(self):
        """
        Handle internal competition state logic
        """
        while True:
            self._update_state()

            if self._mode != self._previous_mode:
                # If the mode has changed since last update
                # then run the appropriate instant callbacks
                self._handle_instant_callbacks()

            self._handle_periodic_callbacks()  # Run the appropriate periodic callbacks every update

    def _handle_instant_callbacks(self):
        if self._enabled:
            self._handle_enable_callbacks()
        else:
            self._handle_disable_callbacks()

    def _handle_enable_callbacks(self):
        """
        Handle callbacks when the robot is enabled
        """
        self._last_enable_time = time.time()
        self.on_enable()
        if self.is_autonomous_control():
            self.on_autonomous()
        elif self.is_driver_control():
            self.on_driver_control()

    def _handle_disable_callbacks(self):
        """
        Handle callbacks when the robot is disabled
        """
        self._last_disable_time = time.time()
        self.on_disable()
        if self.is_autonomous_control():
            self.on_autonomous_disable()
        elif self.is_driver_control():
            self.on_driver_control_disable()

    def _handle_periodic_callbacks(self):
        """
        Handle periodic callbacks
        """
        elapsed_time = self._current_time - self._last_tick_time
        if elapsed_time >= Units.milliseconds_to_seconds(self._warning_tick_duration_ms):
            self.brain.screen.print("WARNING: Loop overrun: Tick time of " + str(elapsed_time) + "ms exceeds " + str(
                self._warning_tick_duration_ms) + "ms")
            print("WARNING: Loop overrun: Tick time of " + str(elapsed_time) + "ms exceeds " + str(
                self._warning_tick_duration_ms) + "ms")
        if elapsed_time >= Units.milliseconds_to_seconds(self._target_tick_duration_ms):
            self._handle_periodic_callbacks_internal()

    def _handle_periodic_callbacks_internal(self):
        """
        Handle the internal logic for periodic callbacks
        """
        if self._enabled:
            if self.is_driver_control():
                self.driver_control_periodic()
            elif self.is_autonomous_control():
                self.autonomous_periodic()
            self.enabled_periodic()
        else:
            self.disabled_periodic()

        self.periodic()
        self._last_tick_time = self._current_time

    """Instant callbacks"""

    def on_enable(self):
        """
        Run whenever the robot is enabled while in either autonomous or driver control mode
        This means that this method is also executed when the robot is enabled and is switched from autonomous to driver control mode or vice versa
        """

    def on_disable(self):
        """
        Run whenever the robot is disabled while in either autonomous or driver control mode
        This means that this method is also executed when the robot is disabled and is switched from autonomous to driver control mode or vice versa
        """

    def on_driver_control(self):
        """
        Run whenever the robot is enabled while in driver control mode or is enabled and switches from autonomous to driver control
        """

    def on_driver_control_disable(self):
        """
        Run whenever the robot is disabled while in driver control mode or is disabled and switches from autonomous to driver control
        """

    def on_autonomous(self):
        """
        Run whenever the robot is enabled while in autonomous mode or is enabled and switches from driver control to autonomous
        """

    def on_autonomous_disable(self):
        """
        Run whenever the robot is disabled while in autonomous mode or is disabled and switches from driver control to autonomous
        """

    """Periodic callbacks"""

    def periodic(self):
        """
        Run periodically approximately 50 times a second (20ms between ticks) no matter the competition mode
        """

    def driver_control_periodic(self):
        """
        Run periodically approximately 50 times a second (20ms between ticks) while driver control is enabled
        """

    def autonomous_periodic(self):
        """
        Run periodically approximately 50 times a second (20ms between ticks) while autonomous is enabled
        """

    def enabled_periodic(self):
        """
        Run periodically approximately 50 times a second (20ms between ticks) while the robot is enabled in either autonomous or driver control mode
        """

    def disabled_periodic(self):
        """
        Run periodically approximately 50 times a second (20ms between ticks) while the robot is disabled in either autonomous or driver control mode
        """

    """Polling methods"""

    def is_enabled(self):
        """
        Get whether the robot is currently enabled
        """
        return self._enabled

    def is_disabled(self):
        """
        Get whether the robot is currently disabled
        """
        return self.is_enabled()

    def is_driver_control(self):
        """
        Get whether the robot is currently in driver control mode
        """
        return self._mode == DRIVER_CONTROL_MODE

    def is_autonomous_control(self):
        """
        Get whether the robot is currently in autonomous control mode
        """
        return self._mode == AUTONOMOUS_MODE

    def get_enabled_runtime(self):
        """
        Get the elapsed time in seconds from when the robot was enabled in either driver or autonomous control

        Returns:
            enabled_runtime (float | None): the elapsed time since the robot was enabled, or None if it is not enabled
        """
        if self.is_enabled() and (self._last_enable_time is not None):
            return time.time() - self._last_enable_time
        return None

    def get_disabled_runtime(self):
        """
        Get the elapsed time in seconds from when the robot was disabled in either driver or autonomous control

        Returns:
            disabled_runtime (float | None): the elapsed time since the robot was disabled, or None if it is not disabled
        """
        if self.is_disabled() and (self._last_disable_time is not None):
            return time.time() - self._last_disable_time
        return None

    def get_autonomous_control_runtime(self):
        """
        Get the elapsed time in seconds from the start of autonomous control

        Returns:
            autonomous_control_runtime (float | None): the elapsed time since the start of autonomous control, or None if it is not running
        """
        enabled_runtime = self.get_enabled_runtime()
        if self.is_autonomous_control() and (enabled_runtime is not None):
            return enabled_runtime
        return None

    def get_driver_control_runtime(self):
        """
        Get the elapsed time in seconds from the start of driver control

        Returns:
            driver_control_runtime (float | None): the elapsed time since the start of driver control, or None if it is not running
        """
        enabled_runtime = self.get_enabled_runtime()
        if self.is_driver_control() and (enabled_runtime is not None):
            return enabled_runtime
        return None

    def get_remaining_driver_control_time(self):
        """
        Get the amount of time remaining in driver control

        Returns:
            driver_control_time_remaining (float): The time remaining in driver control, (0 if no time remains)
        """
        return MathUtil.clamp(DRIVER_CONTROL_TIME_IN_SECONDS - self.get_driver_control_runtime(), 0.0, DRIVER_CONTROL_TIME_IN_SECONDS)

    def get_remaining_autonomous_control_time(self):
        """
        Get the amount of time remaining in autonomous control

        Returns:
            autonomous_control_time_remaining (float): The time remaining in autonomous control, (0 if no time remains)
        """
        return MathUtil.clamp(AUTONOMOUS_TIME_IN_SECONDS - self.get_driver_control_runtime(), 0.0, AUTONOMOUS_TIME_IN_SECONDS)

    def get_remaining_skills_time(self):
        """
        Get the amount of time remaining in a skills run

        Returns:
            skills_run_time_remaining (float): The time remaining in a skills run, (0 if no time remains)
        """
        return MathUtil.clamp(SKILLS_TIME_IN_SECONDS - self.get_enabled_runtime(), 0.0, SKILLS_TIME_IN_SECONDS)
