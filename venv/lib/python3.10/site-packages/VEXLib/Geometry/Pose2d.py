import math
from typing import List
from dataclasses import dataclass
import numpy as np


# Define the Translation2d class
@dataclass
class Translation2d:
    x: float = 0.0
    y: float = 0.0

    def distance(self, other: 'Translation2d') -> float:
        return math.hypot(self.x - other.x, self.y - other.y)

    def rotate_by(self, rotation: 'Rotation2d') -> 'Translation2d':
        cos_theta = math.cos(rotation.angle_rad)
        sin_theta = math.sin(rotation.angle_rad)
        x_new = self.x * cos_theta - self.y * sin_theta
        y_new = self.x * sin_theta + self.y * cos_theta
        return Translation2d(x_new, y_new)


# Define the Rotation2d class
@dataclass
class Rotation2d:
    angle_rad: float = 0.0

    def cos(self) -> float:
        return math.cos(self.angle_rad)

    def sin(self) -> float:
        return math.sin(self.angle_rad)


# Define the Twist2d class
@dataclass
class Twist2d:
    dx: float = 0.0
    dy: float = 0.0
    dtheta: Rotation2d = Rotation2d()


# Define the Transform2d class
@dataclass
class Transform2d:
    translation: Translation2d
    rotation: Rotation2d


# Define the Pose2d class
@dataclass
class Pose2d:
    translation: Translation2d
    rotation: Rotation2d

    def __sub__(self, other: 'Pose2d') -> 'Transform2d':
        pose = self.relative_to(other)
        return Transform2d(pose.translation, pose.rotation)

    def relative_to(self, other: 'Pose2d') -> 'Transform2d':
        transform = Transform2d(other, self)
        return Pose2d(transform.translation, transform.rotation)

    def exp(self, twist: Twist2d) -> 'Pose2d':
        dx = twist.dx
        dy = twist.dy
        dtheta = twist.dtheta.angle_rad

        sin_theta = math.sin(dtheta)
        cos_theta = math.cos(dtheta)

        if abs(dtheta) < 1E-9:
            s = 1.0 - 1.0 / 6.0 * dtheta * dtheta
            c = 0.5 * dtheta
        else:
            s = sin_theta / dtheta
            c = (1 - cos_theta) / dtheta

        translation = Translation2d(dx * s - dy * c, dx * c + dy * s)
        rotation = Rotation2d(cos_theta, sin_theta)
        transform = Transform2d(translation, rotation)

        return Pose2d(self.translation + transform.translation.rotate_by(self.rotation),
                      Rotation2d(self.rotation.cos() * rotation.cos() - self.rotation.sin() * rotation.sin(),
                                 self.rotation.sin() * rotation.cos() + self.rotation.cos() * rotation.sin()))

    def log(self, end: 'Pose2d') -> Twist2d:
        transform = end.relative_to(self)
        dtheta = transform.rotation.angle_rad
        half_dtheta = dtheta / 2.0
        cos_minus_one = transform.rotation.cos() - 1

        if abs(cos_minus_one) < 1E-9:
            half_theta_by_tan_of_half_dtheta = 1.0 - 1.0 / 12.0 * dtheta * dtheta
        else:
            half_theta_by_tan_of_half_dtheta = -(half_dtheta * transform.rotation.sin()) / cos_minus_one

        translation_part = transform.translation.rotate_by(
            Rotation2d(half_theta_by_tan_of_half_dtheta, -half_dtheta)) * math.hypot(half_theta_by_tan_of_half_dtheta,
                                                                                     half_dtheta)

        return Twist2d(translation_part.x, translation_part.y, Rotation2d(dtheta))

    def nearest(self, poses: List['Pose2d']) -> 'Pose2d':
        return min(poses, key=lambda pose: (self.translation.distance(pose.translation),
                                            abs((self.rotation - pose.rotation).angle_rad)))

    @staticmethod
    def from_json(json_data):
        translation = Translation2d(json_data['translation']['x'], json_data['translation']['y'])
        rotation = Rotation2d(json_data['rotation']['angle_rad'])
        return Pose2d(translation, rotation)

    def to_json(self):
        return {
            'translation': {'x': self.translation.x, 'y': self.translation.y},
            'rotation': {'angle_rad': self.rotation.angle_rad}
        }


# Example usage:
if __name__ == "__main__":
    # Create instances of Pose2d, Twist2d, Translation2d, and Rotation2d as needed
    pose1 = Pose2d(Translation2d(1.0, 2.0), Rotation2d(math.pi / 4))
    pose2 = Pose2d(Translation2d(3.0, 4.0), Rotation2d(math.pi / 3))
    twist = Twist2d(0.5, 0.5, Rotation2d(math.pi / 6))

    # Perform operations
    transform = pose1 - pose2
    exp_pose = pose1.exp(twist)
    log_twist = pose1.log(pose2)
    nearest_pose = pose1.nearest([pose2])

    # Output results
    print("Transform:", transform)
    print("Exp Pose:", exp_pose)
    print("Log Twist:", log_twist)
    print("Nearest Pose:", nearest_pose)
