from VEXLib.Threading.SafeList import SafeList
from VEXLib.Motor import Motor
from VEXLib.Motor.Constants import *
from .Constants import FILE_TERMINATION_CHARACTER
from vex import *
import sys

brain = Brain()


class SerialCommunicationProtocol:
    def __init__(self):
        self.incoming_messages = SafeList()
        self.outgoing_messages = SafeList()

        Thread(self.get_loop)
        Thread(self.send_loop)

    def get_loop(self):
        while True:
            self.incoming_messages.append(sys.stdin.readline().strip("\n"))

    def send_loop(self):
        while True:
            if self.has_outgoing_messages():
                sys.stdout.write(str(self.outgoing_messages.pop(0)) + "\n")

    def has_incoming_messages(self):
        return bool(self.incoming_messages)

    def has_outgoing_messages(self):
        return bool(self.outgoing_messages)

    def send(self, message):
        self.outgoing_messages.append(message)

    def receive(self, blocking=False):
        if blocking:
            while not self.has_incoming_messages():
                pass
        if self.has_incoming_messages():
            return self.incoming_messages.pop(0)
        return None

    def read_file(self):
        file_contents = ""
        self.send("Ready to receive file, waiting for filename")
        while not self.has_incoming_messages():
            pass
        filename = self.receive()
        brain.screen.print("Receiving file: " + filename)
        brain.screen.next_row()
        self.send("Receiving file: " + filename)

        while True:
            chunk = self.receive(True)
            brain.screen.print("Read chunk: " + chunk)
            brain.screen.next_row()

            if FILE_TERMINATION_CHARACTER not in chunk:
                file_contents += chunk + "\n"
            else:
                break
        return filename, file_contents


class Telemetry:
    def __init__(self):
        self.serial = SerialCommunicationProtocol()

        self.telemetry_entries = []

    def register_entry(self, entry):
        self.telemetry_entries.append(entry)

    def update(self):
        for entry in self.telemetry_entries:
            entry.schedule_send()

    def send_telemetry_message(self, name, message):
        self.serial.send(str(name) + ": " + str(message))


def main():
    motor_1 = Motor(1, run_mode=PID_VELOCITY_CONTROL)

    telemetry = Telemetry()
    current_time_entry = TelemetryEntry(telemetry, "time")
    motor_1_entry = TelemetryMotorEntry(telemetry, motor_1, "motor_1")

    while True:
        if telemetry.serial.has_incoming_messages():
            received = telemetry.serial.receive()
            brain.screen.print(received)
            brain.screen.next_row()
            if "tx" in received:
                file_path, file_contents = telemetry.serial.read_file()
                brain.screen.clear_screen()
                brain.screen.set_cursor(1, 1)
                brain.screen.print("file path: " + file_path)
                brain.screen.next_row()
                brain.screen.print("file contents: " + file_contents)
                with open(file_path, "w") as f:
                    f.write(file_contents)
        current_time_entry.set_value(brain.timer.time(SECONDS))
        telemetry.update()
        wait(100, MSEC)


class TelemetryEntry:
    def __init__(self, telemetry, name):
        telemetry.register_entry(self)
        self.telemetry = telemetry
        self.name = name
        self.value = None

    def set_value(self, value):
        self.value = value

    def get_value(self):
        return self.value

    def schedule_send(self):
        self.telemetry.send_telemetry_message(self.name, self.get_value())


class TelemetryMotorEntry(TelemetryEntry):
    def __init__(self, telemetry, motor, name):
        super().__init__(telemetry, name)
        self.motor = motor

    def get_value(self):
        return "Motor at port " + str(self.motor.port) + " running at speed: " + str(self.motor.get_velocity_rotations_per_second())


class TelemetryInertialEntry(TelemetryEntry):
    def __init__(self, telemetry, inertial, name):
        super().__init__(telemetry, name)
        self.inertial = inertial

    def get_value(self):
        return "Inertial at port " + str(self.inertial.port) + " heading: " + str(self.inertial.heading_degrees())
