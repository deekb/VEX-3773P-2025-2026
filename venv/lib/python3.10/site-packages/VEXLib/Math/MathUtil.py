import math


class MathUtil:
    def __init__(self):
        raise AssertionError("This is a utility class, please do not instantiate it")

    @staticmethod
    def sign(x):
        return x / abs(x)

    @staticmethod
    def average(*args) -> float:
        """
        Restricts a value within a specified range.

        Args:
            *args: The values to average.

        Returns:
            The average value.
        """

        return sum(args) / len(args)

    @staticmethod
    def average_iterable(iterable) -> float:
        """
        Restricts a value within a specified range.

        Args:
            iterable: The list of values to average.

        Returns:
            The average value.
        """

        return sum(iterable) / len(iterable)

    @staticmethod
    def clamp(value: float, lower_limit: float = None, upper_limit: float = None) -> float:
        """
        Restricts a value within a specified range.

        Args:
            value: The value to be clamped.
            lower_limit: The lower limit of the range. If None is specified, no lower limit is applied.
            upper_limit: The upper limit of the range. If None is specified, no upper limit is applied.

        Returns:
            The clamped value.
        """

        if upper_limit < lower_limit:
            raise ValueError(
                "The value of upper_limit should be greater than or equal to that of lower_limit"
            )

        if lower_limit is not None:
            if value < lower_limit:
                return lower_limit
        if upper_limit is not None:
            if value > upper_limit:
                return upper_limit
        return value

    @staticmethod
    def apply_deadband(value, deadband, max_magnitude):
        """
        Returns 0.0 if the given value is within the specified range around zero. The remaining range
        between the deadband and the maximum magnitude is scaled from 0.0 to the maximum magnitude.

        Args:
            value: The value to clip.
            deadband: The range around zero.
            max_magnitude: The maximum magnitude of the input. Can be infinite.

        Returns:
            The value after the deadband is applied.
        """

        if abs(value) > deadband:
            if max_magnitude / deadband > 1.0e12:
                # If max magnitude is sufficiently large, the implementation encounters
                # roundoff error.  Implementing the limiting behavior directly avoids
                # the problem.
                return value - deadband if (value > 0.0) else value + deadband
            if value > 0.0:
                # Map deadband to 0 and map max to max.
                #
                # y - y₁ = m(x - x₁)
                # y - y₁ = (y₂ - y₁)/(x₂ - x₁) (x - x₁)
                # y = (y₂ - y₁)/(x₂ - x₁) (x - x₁) + y₁
                #
                # (x₁, y₁) = (deadband, 0) and (x₂, y₂) = (max, max).
                # x₁ = deadband
                # y₁ = 0
                # x₂ = max
                # y₂ = max
                #
                # y = (max - 0)/(max - deadband) (x - deadband) + 0
                # y = max/(max - deadband) (x - deadband)
                # y = max (x - deadband)/(max - deadband)
                return max_magnitude * (value - deadband) / (max_magnitude - deadband)
            else:
                # Map -deadband to 0 and map -max to -max.
                #
                # y - y₁ = m(x - x₁)
                # y - y₁ = (y₂ - y₁)/(x₂ - x₁) (x - x₁)
                # y = (y₂ - y₁)/(x₂ - x₁) (x - x₁) + y₁
                #
                # (x₁, y₁) = (-deadband, 0) and (x₂, y₂) = (-max, -max).
                # x₁ = -deadband
                # y₁ = 0
                # x₂ = -max
                # y₂ = -max
                #
                # y = (-max - 0)/(-max + deadband) (x + deadband) + 0
                # y = max/(max - deadband) (x + deadband)
                # y = max (x + deadband)/(max - deadband)
                return max_magnitude * (value + deadband) / (max_magnitude - deadband)
        else:
            return 0.0

    @staticmethod
    def input_modulus(value, minimum_value, maximum_value):
        """
        Returns modulus of input.

        Args:
            value: Input value to wrap.
            minimum_value: The minimum value expected from the input.
            maximum_value: The maximum value expected from the input.

        Returns:
            The wrapped value.
        """

        modulus = maximum_value - minimum_value

        # Wrap input if it's above the maximum input
        num_max = ((value - minimum_value) / modulus)
        value -= num_max * modulus

        # Wrap input if it's below the minimum input
        num_min = ((value - maximum_value) / modulus)
        value -= num_min * modulus

        return value

    @classmethod
    def angle_modulus(cls, angle_radians):
        """
        Wraps an angle to the range -pi to pi radians.

        Args:
            angle_radians: Angle to wrap in radians.

        Returns:
            The wrapped angle.
        """

        return cls.input_modulus(angle_radians, -math.pi, math.pi)

    @staticmethod
    def interpolate(start_value, end_value, t):
        """
        Perform linear interpolation between two values.

        Args:
            start_value: The value to start at.
            end_value: The value to end at.
            t: How far between the two values to interpolate. With zero corresponding to start_value and 1 corresponding to end_value This is clamped to the range [0, 1].

        Returns:
            The interpolated value.
        """

        return start_value + (end_value - start_value) * MathUtil.clamp(t, 0, 1)

    @staticmethod
    def interpolate_2d(x1: float, x2: float, y1: float, y2: float, x: float) -> float:
        """
        Perform linear interpolation for x between (x1,y1) and (x2,y2)

        Args:
            x1: The first point's X value
            x2: The first point's Y value
            y1: The second point's X value
            y2: The second point's Y value
            x: The x value to interpolate the Y value for

        Returns:
            The Y value for the given x value, calculated using linear interpolation from the points given
        """

        return ((y2 - y1) * x + x2 * y1 - x1 * y2) / (x2 - x1)

    @staticmethod
    def inverse_interpolate(start_value, end_value, q):
        """
        Return where within interpolation range [0, 1] q is between start_value and end_value.

        Args:
            start_value (float): Lower part of interpolation range.
            end_value (float): Upper part of interpolation range.
            q (float): Query.

        Returns:
            float: Interpolant in range [0, 1].
        """

        total_range = end_value - start_value
        if total_range <= 0:
            return 0.0

        query_to_start = q - start_value
        if query_to_start <= 0:
            return 0.0

        return query_to_start / total_range

    @staticmethod
    def is_near(expected, actual, tolerance) -> bool:
        """
        Checks if the given value matches an expected value within a certain tolerance.

        Args:
            expected (float): The expected value.
            actual (float): The actual value.
            tolerance (float): The allowed difference between the actual and the expected value.

        Returns:
            bool: Whether the actual value is within the allowed tolerance.
        """

        if tolerance < 0:
            raise ValueError("Tolerance must be a non-negative number!")

        return abs(expected - actual) < tolerance

    @staticmethod
    def is_near_continuous(expected, actual, tolerance, minimum, maximum):
        """
        Checks if the given value matches an expected value within a certain tolerance. Supports
        continuous input for cases like absolute encoders.

        Continuous input means that the min and max value are considered to be the same point, and
        tolerances can be checked across them. A common example would be for absolute encoders: calling
        is_near_continuous(2, 359, 5, 0, 360) returns true because 359 is 1 away from 360 (which is treated as the
        same as 0) and 2 is 2 away from 0, adding up to an error of 3 degrees, which is within the
        given tolerance of 5.

        Args:
            expected (float): The expected value.
            actual (float): The actual value.
            tolerance (float): The allowed difference between the actual and the expected value.
            minimum (float): Smallest value before wrapping around to the largest value.
            maximum (float): Largest value before wrapping around to the smallest value.

        Returns:
            bool: Whether the actual value is within the allowed tolerance.
        """

        if tolerance < 0:
            raise ValueError("Tolerance must be a non-negative number!")

        # Max error is exactly halfway between the min and max
        error_bound = (maximum - minimum) / 2.0
        error = MathUtil.input_modulus(expected - actual, -error_bound, error_bound)
        return abs(error) < tolerance

    @staticmethod
    def hypotenuse(x: float, y: float) -> float:
        """
        Get the hypotenuse length of a right triangle with sides x and y

        Args:
            x: The length of one leg of the triangle
            y: The length of the other leg of the triangle

        Returns:
            The hypotenuse length of a right triangle with side lengths x and y
        """

        return math.sqrt(pow(x, 2) + pow(y, 2))

    @staticmethod
    def distance(point1, point2) -> float:
        """
        Get the distance between point_1 and point_2

        Args:
            point1: One of the points
            point2: The other point

        Returns:
            The distance between point_1 and point_2
        """

        return MathUtil.hypotenuse(point1[0] - point2[0], point1[1] - point2[1])

    @staticmethod
    def cubic_filter(value, linearity=0) -> float:
        """
        Apply a cubic filter to a value with a given linearity

        Args:
            value: The value between -1 to 1 to apply the filter to
            linearity: How linear to make the filter (0 for fully cubic, 1 for fully linear)

        Returns:
            The input value with a cubic filter applied
        """

        if abs(value) > 1:
            raise ValueError("Input value must be between -1 and 1")
        if linearity < 0 or linearity > 1:
            raise ValueError("Linearity must be between 0 and 1 (inclusive))")

        return ((value ** 3) * (1 - linearity)) + value * linearity

    @classmethod
    def distance_from_point_to_line(cls, point, slope, x_intercept, y_intercept):
        # Convert the line equation to standard form: (Ax - y + C = 0)

        a = slope
        b = -1
        c = y_intercept
        # Extract the coordinates of the point
        x0, y0 = point
        # Calculate the distance using the formula
        if math.isinf(slope):
            return abs(x0 - x_intercept)
        else:
            return abs(a * x0 + b * y0 + c) / cls.hypotenuse(a, b)

