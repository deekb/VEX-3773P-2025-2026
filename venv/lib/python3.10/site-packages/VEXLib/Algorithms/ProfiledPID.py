from typing import NamedTuple


class TrapezoidProfileState(NamedTuple):
    position: float
    velocity: float


class TrapezoidProfileConstraints(NamedTuple):
    max_velocity: float
    max_acceleration: float


class PIDController:
    def __init__(self, Kp: float, Ki: float, Kd: float, period: float):
        self.Kp = Kp
        self.Ki = Ki
        self.Kd = Kd
        self.period = period
        self.integral = 0.0
        self.prev_error = 0.0

    def calculate(self, measurement: float, setpoint: float) -> float:
        # PID calculation
        error = setpoint - measurement
        self.integral += error * self.period
        derivative = (error - self.prev_error) / self.period
        output = self.Kp * error + self.Ki * self.integral + self.Kd * derivative
        self.prev_error = error
        return output

    def reset(self):
        self.integral = 0.0
        self.prev_error = 0.0


class ProfiledPIDController:
    def __init__(self, Kp: float, Ki: float, Kd: float, constraints: TrapezoidProfileConstraints, period: float = 0.02):
        self.m_controller = PIDController(Kp, Ki, Kd, period)
        self.m_minimum_input = 0.0
        self.m_maximum_input = 0.0
        self.m_constraints = constraints
        self.m_profile = None  # Initialized in set_constraints method
        self.m_goal = TrapezoidProfileState(0.0, 0.0)
        self.m_setpoint = TrapezoidProfileState(0.0, 0.0)

    def set_constraints(self, constraints: TrapezoidProfileConstraints):
        self.m_constraints = constraints
        self.m_profile = TrapezoidProfile(self.m_constraints)

    def set_goal(self, goal: TrapezoidProfileState):
        self.m_goal = goal

    def calculate(self, measurement: float) -> float:
        if self.m_controller.is_continuous_input_enabled():
            # Get error which is the smallest distance between goal and measurement
            error_bound = (self.m_maximum_input - self.m_minimum_input) / 2.0
            goal_min_distance = (self.m_goal.position - measurement) % error_bound
            setpoint_min_distance = (self.m_setpoint.position - measurement) % error_bound

            # Recompute the profile goal with the smallest error, thus giving the shortest path
            self.m_goal = TrapezoidProfileState(goal_min_distance + measurement, 0.0)
            self.m_setpoint = TrapezoidProfileState(setpoint_min_distance + measurement, 0.0)

        self.m_setpoint = self.m_profile.calculate(self.get_period(), self.m_setpoint, self.m_goal)
        return self.m_controller.calculate(measurement, self.m_setpoint.position)

    def get_period(self) -> float:
        return self.m_controller.period

    def at_setpoint(self) -> bool:
        return self.m_controller.at_setpoint()

    def enable_continuous_input(self, minimum_input: float, maximum_input: float):
        self.m_controller.enable_continuous_input(minimum_input, maximum_input)
        self.m_minimum_input = minimum_input
        self.m_maximum_input = maximum_input


# Usage:
# Define constraints and create ProfiledPIDController instance
constraints = TrapezoidProfileConstraints(max_velocity=1.0, max_acceleration=0.5)
controller = ProfiledPIDController(Kp=1.0, Ki=0.0, Kd=0.0, constraints=constraints)

# Set goal and calculate output
goal_state = TrapezoidProfileState(position=10.0, velocity=0.0)
controller.set_goal(goal_state)
output = controller.calculate(measurement=5.0)
