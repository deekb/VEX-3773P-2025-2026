from vex import Brain, Thread, wait, PERCENT, SECONDS
from ..Math.MathUtil import MathUtil
from ..Util import time as time


class MotorPID:
    """
    Wrap a motor definition in this class to use a custom PID to control its movements ie: my_motor = MotorPID(Motor(...), kp, kd, t)
    **Waring, this class disables all motor functionality except the following functions:[set_velocity, set_stopping, stop, spin, velocity]**
    """

    def __init__(
        self,
        timer: Brain.timer,
        motor_object,
        kp: float = 1,
        ki: float = 0,
        kd: float = 0,
        t: float = 0.05,
    ):
        """
        Creates an instance of the MotorPID

        Args:
            motor_object: The motor to apply the PID to
            kp: Kp value for the PID: How quickly to modify the target value if it has not yet reached the desired value
            ki: Ki value for the PID: Integral gain to reduce steady-state error
            kd: Kd value for the PID: Higher values reduce the response time and limit overshoot
            t: Time between PID updates
        """
        self.motor_object = motor_object
        self.motor_PID = PIDController(kp, ki, kd)
        self.pid_thread = Thread(self._loop)
        self.t = t

    def update(self) -> None:
        """
        Update the PID state with the most recent motor and target velocities and send the normalized value to the motor
        """

        self.motor_object.set_velocity(self.motor_PID.update(self.velocity()), PERCENT)

    def _loop(self) -> None:
        """
        Used to run the PID in a new thread: updates the values the PID uses and handles
          applying the PID output to the motor
        """

        while True:
            self.update()
            wait(self.t, SECONDS)

    def set_velocity(self, velocity: float) -> None:
        """
        Set the motor's target velocity using the PID, make sure you run PID_loop in a new thread or this
        will have no effect
        :param velocity: The new target velocity of the motor
        :type velocity: float
        """

        self.motor_PID._target_value = velocity

    def spin(self, direction):
        self.motor_object.spin(direction)

    def stop(self):
        self.motor_object.stop()

    def velocity(self):
        return self.motor_object.velocity(PERCENT)


class PIDController:
    """
    A generalized PID controller implementation.
    """

    def __init__(
        self,
        kp: float = 1.0,
        ki: float = 0.0,
        kd: float = 0.0,
        t: float = 0.05,
        integral_limit: float = 1.0,
    ):
        """
        Initializes a PIDController instance.

        Args:
            kp: Kp value for the PID.
            ki: Ki value for the PID.
            kd: Kd value for the PID.
            t: Minimum time between update calls. All calls made before this amount of time has passed since the last calculation will be ignored.
            integral_limit: The maximum absolute value for the integral term to prevent windup.
        """

        self._kp = kp
        self._ki = ki
        self._kd = kd
        self._time_step = t
        self._previous_time = time.time()
        self._current_value = 0.0
        self._target_value = 0.0
        self._error_integral = 0.0
        self._integral_limit = integral_limit
        self._previous_error = 0.0
        self._control_output = 0.0

    @property
    def kp(self) -> float:
        """
        Getter for the Kp value of the PID.
        :return: The Kp value.
        """

        return self._kp

    @kp.setter
    def kp(self, value: float):
        """
        Setter for the Kp value of the PID.
        :param value: The new Kp value.
        """

        self._kp = value

    @property
    def ki(self) -> float:
        """
        Getter for the Ki value of the PID.
        :return: The Ki value.
        """

        return self._ki

    @ki.setter
    def ki(self, value: float):
        """
        Setter for the Ki value of the PID.
        :param value: The new Ki value.
        """

        self._ki = value

    @property
    def kd(self) -> float:
        """
        Getter for the Kd value of the PID.
        :return: The Kd value.
        """

        return self._kd

    @kd.setter
    def kd(self, value: float):
        """
        Setter for the Kd value of the PID.
        :param value: The new Kd value.
        """

        self._kd = value

    @property
    def setpoint(self) -> float:
        """
        Getter for the target value of the PID.
        :return: The target value.
        """

        return self._target_value

    @setpoint.setter
    def setpoint(self, value: float):
        """
        Setter for the target value of the PID.
        :param value: The new target value.
        """
        self._target_value = value

    def reset(self):
        self._error_integral = 0
        self._control_output = 0
        self._previous_error = self._target_value - self._current_value

    def update(self, current_value: float) -> float:
        """
        Update the PID state with the most recent current value and calculate the control output.

        Args:
            current_value: The current measurement or feedback value

        Returns:
            The calculated control output.
        """

        current_time = time.time()
        delta_time = current_time - self._previous_time

        if delta_time < self._time_step:
            # If the elapsed time since the last calculation is less than the time step, then
            # return the last output without recalculating
            return self._control_output

        self._previous_time = current_time

        current_error = self._target_value - current_value
        self._error_integral += current_error * delta_time
        # Apply integral windup prevention
        # PID integral windup is a phenomenon that occurs when the integral term of a PID
        # controller continues to accumulate error even when the controller's output is saturated.
        # This can lead to overshoot, instability, and poor performance in control systems.
        # if your Ki is not zero and your Kp is reasonably low, and you are still experiencing overshoot/instability/oscillation,
        # then try decreasing the integral limit
        if self._ki != 0:
            self._error_integral = MathUtil.clamp(
                self._error_integral, -self._integral_limit, self._integral_limit
            )
        error_derivative = (current_error - self._previous_error) / delta_time
        self._control_output = (
            self._kp * current_error
            + self._ki * self._error_integral
            + self._kd * error_derivative
        )
        self._previous_error = current_error
        return self._control_output
