from vex import Thread, wait, PERCENT, RPM, SECONDS
from ..Math import MathUtil
from VEXLib.Units import Units
from ..Util import time as time


class PIDMotorController:
    """
    Wrap a motor definition in this class to use a custom PID to control its movements ie: my_tunable_PID_motor = MotorPID(Motor(...), PID_controller)
    **Waring, this class disables all motor functionality except the following functions:[set_target_velocity_<unit>, stop, spin, get_velocity_<unit>]**
    """

    def __init__(self, motor, PID_controller):
        """
        Creates an instance of the MotorPID

        Args:
            motor: The motor to apply the PID to
            PID_controller: The PID controller for
        """
        self.motor = motor
        self.PID_controller = PID_controller
        self.pid_thread = Thread(self._loop)

    def update(self) -> None:
        """
        Update the PID state with the most recent motor and target velocities and send the normalized value to the motor
        """

        self.motor.set_velocity(self.PID_controller.update(self.get_velocity_rads_per_second()), PERCENT)

    def _loop(self) -> None:
        """
        Used to run the PID in a new thread: updates the values the PID uses and handles
          applying the PID output to the motor
        """

        while True:
            self.update()
            wait(self.PID_controller.t, SECONDS)

    def set_target_velocity_rad_per_second(self, velocity: float) -> None:
        """
        Set the motor's target velocity using the PID, make sure you run PID_loop in a new thread or this
        will have no effect
        :param velocity: The new target velocity of the motor
        :type velocity: float
        """

        self.PID_controller.setpoint = velocity

    def stop(self):
        self.set_target_velocity_rad_per_second(0)

    def get_velocity_rotations_per_minute(self):
        return self.motor.velocity(RPM)

    def get_velocity_rads_per_second(self):
        return Units.rotations_per_minute_to_radians_per_second(self.get_velocity_rotations_per_minute())

    def get_velocity_rotations_per_second(self):
        return Units.rotations_per_minute_to_rotations_per_second(self.get_velocity_rotations_per_minute())


class PIDMotorGroupController:
    pass


class PIDController:
    def __init__(self, kp: float = 1.0, ki: float = 0.0, kd: float = 0.0, t: float = 0.05, integral_limit: float = 1.0):
        """
        Initializes a PIDController instance.

        Args:
            kp: Kp value for the PID.
            ki: Ki value for the PID.
            kd: Kd value for the PID.
            t: Minimum time between update calls. All calls made before this amount of time has passed since the last calculation will be ignored.
            integral_limit: The maximum absolute value for the integral term to prevent windup.
        """
        self._kp = kp
        self._ki = ki
        self._kd = kd
        self._time_step = t
        self._previous_time = time.time()
        self._current_value = 0.0
        self._target_value = 0.0
        self._error_integral = 0.0
        self._integral_limit = integral_limit
        self._previous_error = 0.0
        self._control_output = 0.0

        # Continuous input attributes
        self._continuous_input_enabled = False
        self._minimum_input = float("-inf")
        self._maximum_input = float("inf")
    #
    # def enable_continuous_input(self, minimum_input: float, maximum_input: float) -> None:
    #     """
    #     Enable continuous input mode, specifying the minimum and maximum values of the input range.
    #
    #     Args:
    #         minimum_input: The minimum input value.
    #         maximum_input: The maximum input value.
    #     """
    #     self._continuous_input_enabled = True
    #     self._minimum_input = minimum_input
    #     self._maximum_input = maximum_input
    #
    # def disable_continuous_input(self) -> None:
    #     """
    #     Disable continuous input mode.
    #     """
    #     self._continuous_input_enabled = False
    #
    # def _calculate_continuous_error(self, error: float) -> float:
    #     """
    #     Calculate the shortest path for the error if continuous input is enabled.
    #
    #     Args:
    #         error: The raw error value.
    #
    #     Returns:
    #         The shortest path error.
    #     """
    #     if not self._continuous_input_enabled:
    #         return error
    #
    #     input_range = self._maximum_input - self._minimum_input
    #     # Normalize the error within the range
    #     error = ((error - self._minimum_input) % input_range) + self._minimum_input
    #
    #     # Adjust if the error exceeds half the range in either direction
    #     if error > input_range / 2.0:
    #         error -= input_range
    #     elif error < -input_range / 2.0:
    #         error += input_range
    #
    #     return error

    def update(self, current_value: float) -> float:
        """
        Update the PID state with the most recent current value and calculate the control output.

        Args:
            current_value: The current measurement or feedback value

        Returns:
            The calculated control output.
        """
        current_time = time.time()
        delta_time = current_time - self._previous_time

        if delta_time < self._time_step:
            # If the elapsed time since the last calculation is less than the time step, then
            # return the last output without recalculating
            return self._control_output

        self._previous_time = current_time
        self._current_value = current_value

        # Calculate the error and adjust for continuous input if enabled
        current_error = self.setpoint - self._current_value
        # current_error = self._calculate_continuous_error(current_error)

        self._error_integral += current_error * delta_time
        if self._ki != 0:
            self._error_integral = MathUtil.clamp(self._error_integral, -self._integral_limit, self._integral_limit)
        if self._kd != 0:
            error_derivative = (current_error - self._previous_error) / delta_time
        else:
            error_derivative = 0.0

        self._control_output = (
                self._kp * current_error + self._ki * self._error_integral + self._kd * error_derivative
        )
        self._previous_error = current_error
        return self._control_output

    @property
    def kp(self) -> float:
        """
        Getter for the Kp value of the PID.
        :return: The Kp value.
        """

        return self._kp

    @kp.setter
    def kp(self, value: float):
        """
        Setter for the Kp value of the PID.
        :param value: The new Kp value.
        """

        self._kp = value

    @property
    def ki(self) -> float:
        """
        Getter for the Ki value of the PID.
        :return: The Ki value.
        """

        return self._ki

    @ki.setter
    def ki(self, value: float):
        """
        Setter for the Ki value of the PID.
        :param value: The new Ki value.
        """

        self._ki = value

    @property
    def kd(self) -> float:
        """
        Getter for the Kd value of the PID.
        :return: The Kd value.
        """

        return self._kd

    @kd.setter
    def kd(self, value: float):
        """
        Setter for the Kd value of the PID.
        :param value: The new Kd value.
        """

        self._kd = value

    @property
    def setpoint(self) -> float:
        """
        Getter for the target value of the PID.
        :return: The target value.
        """

        return self._target_value

    @setpoint.setter
    def setpoint(self, value: float):
        """
        Setter for the target value of the PID.
        :param value: The new target value.
        """
        self._target_value = value

    def at_setpoint(self, threshold=0.05):
        return abs(self._previous_error) <= threshold

    def reset(self):
        self._error_integral = 0
        self._control_output = 0
        self._previous_error = self._target_value - self._current_value
