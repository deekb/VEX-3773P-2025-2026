from vex import Thread, wait, PERCENT, RPM, SECONDS
from ..Math.MathUtil import MathUtil
from VEXLib.Units.Units import Units
from ..Util import time as time


class PIDMotorController:
    """
    Wrap a motor definition in this class to use a custom PID to control its movements ie: my_tunable_PID_motor = MotorPID(Motor(...), PID_controller)
    **Waring, this class disables all motor functionality except the following functions:[set_target_velocity_<unit>, stop, spin, get_velocity_<unit>]**
    """

    def __init__(self, motor, PID_controller):
        """
        Creates an instance of the MotorPID

        Args:
            motor: The motor to apply the PID to
            PID_controller: The PID controller for
        """
        self.motor = motor
        self.PID_controller = PID_controller
        self.pid_thread = Thread(self._loop)

    def update(self) -> None:
        """
        Update the PID state with the most recent motor and target velocities and send the normalized value to the motor
        """

        self.motor.set_velocity(self.PID_controller.update(self.get_velocity_rads_per_second()), PERCENT)

    def _loop(self) -> None:
        """
        Used to run the PID in a new thread: updates the values the PID uses and handles
          applying the PID output to the motor
        """

        while True:
            self.update()
            wait(self.PID_controller.t, SECONDS)

    def set_target_velocity_rad_per_second(self, velocity: float) -> None:
        """
        Set the motor's target velocity using the PID, make sure you run PID_loop in a new thread or this
        will have no effect
        :param velocity: The new target velocity of the motor
        :type velocity: float
        """

        self.PID_controller.setpoint = velocity

    def stop(self):
        self.set_target_velocity_rad_per_second(0)

    def get_velocity_rotations_per_minute(self):
        return self.motor.velocity(RPM)

    def get_velocity_rads_per_second(self):
        return Units.rotations_per_minute_to_radians_per_second(self.get_velocity_rotations_per_minute())

    def get_velocity_rotations_per_second(self):
        return Units.rotations_per_minute_to_rotations_per_second(self.get_velocity_rotations_per_minute())


class PIDMotorGroupController:
    pass


class PIDController:
    def __init__(self, kp: float = 1.0, ki: float = 0.0, kd: float = 0.0, t: float = 0.05, integral_limit: float = 1.0,
                 fade_time: float = 0.0):
        """
        Initializes a PIDController instance.

        Args:
            kp: Kp value for the PID.
            ki: Ki value for the PID.
            kd: Kd value for the PID.
            t: Minimum time between update calls. All calls made before this amount of time has passed since the last calculation will be ignored.
            integral_limit: The maximum absolute value for the integral term to prevent windup.
        """

        self._kp = kp
        self._ki = ki
        self._kd = kd
        self._time_step = t
        self._previous_time = time.time()
        self._current_value = 0.0
        self._target_value = 0.0
        self._error_integral = 0.0
        self._integral_limit = integral_limit
        self._previous_error = 0.0
        self._control_output = 0.0

    @property
    def kp(self) -> float:
        """
        Getter for the Kp value of the PID.
        :return: The Kp value.
        """

        return self._kp

    @kp.setter
    def kp(self, value: float):
        """
        Setter for the Kp value of the PID.
        :param value: The new Kp value.
        """

        self._kp = value

    @property
    def ki(self) -> float:
        """
        Getter for the Ki value of the PID.
        :return: The Ki value.
        """

        return self._ki

    @ki.setter
    def ki(self, value: float):
        """
        Setter for the Ki value of the PID.
        :param value: The new Ki value.
        """

        self._ki = value

    @property
    def kd(self) -> float:
        """
        Getter for the Kd value of the PID.
        :return: The Kd value.
        """

        return self._kd

    @kd.setter
    def kd(self, value: float):
        """
        Setter for the Kd value of the PID.
        :param value: The new Kd value.
        """

        self._kd = value

    @property
    def setpoint(self) -> float:
        """
        Getter for the target value of the PID.
        :return: The target value.
        """

        return self._target_value

    @setpoint.setter
    def setpoint(self, value: float):
        """
        Setter for the target value of the PID.
        :param value: The new target value.
        """
        self._target_value = value

    def reset(self):
        self._error_integral = 0
        self._control_output = 0
        self._previous_error = self._target_value - self._current_value

    def update(self, current_value: float) -> float:
        """
        Update the PID state with the most recent current value and calculate the control output.

        Args:
            current_value: The current measurement or feedback value

        Returns:
            The calculated control output.
        """

        current_time = time.time()
        delta_time = current_time - self._previous_time

        if delta_time < self._time_step:
            # If the elapsed time since the last calculation is less than the time step, then
            # return the last output without recalculating
            return self._control_output

        self._previous_time = current_time

        current_error = self._target_value - current_value
        self._error_integral += current_error * delta_time
        # Apply integral windup prevention
        # PID integral windup is a phenomenon that occurs when the integral term of a PID
        # controller continues to accumulate error even when the controller's output is saturated.
        # This can lead to overshoot, instability, and poor performance in control systems.
        # if your Ki is not zero and your Kp is reasonably low, and you are still experiencing overshoot/instability/oscillation,
        # then try decreasing the integral limit
        if self._ki != 0:
            self._error_integral = MathUtil.clamp(self._error_integral, -self._integral_limit, self._integral_limit)
        if self._kd != 0:
            error_derivative = (current_error - self._previous_error) / delta_time
        else:
            error_derivative = 0.0

        self._control_output = (
                self._kp * current_error + self._ki * self._error_integral + self._kd * error_derivative)
        self._previous_error = current_error
        return self._control_output
